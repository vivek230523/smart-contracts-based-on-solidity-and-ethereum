// contract test code will go here
//we use mocha for testing out our contracts and we do this so as to see if our contract is behaving in the way we want it to mocha is a test
//running framework and we can use it to test any type of javasript code that we want
const assert = require('assert');
//std library built in to nodejs runtime and it is used to make assertions about tests like we might want to assert that some value is equal to
//another value
const ganache = require('ganache-cli');
//here ganche is going to serve as our local ethereum test network and it provides us with some already unlocked accounts with some etherum
//int them for testing purposes and we are going to make the use of web3 to use these unlocked accounts
const Web3=require('web3');
//web3 library is our portal to the network helps us connect the interface code to our test network and Web3 here is a constructor(instance) of
//the web3 library and whenever we make use of the web3 library we always require in a constructor function which then we use to create
//instances of the web3 library and the purpose of each instance is to connect to a different ethereum network
const web3 = new Web3(ganache.provider());
//in the above line of code we create a instanec of the web3 library using the Web3 constructor and we tell it to use the provider provided to
//us by the ganache test network and as we create a new instance of the web3 library we have to immediatly do some configuration .i.e, we have
//to setup something called a provider: can be thought of as a communication layer between the web3 library and some specific ethereum network
//in our case the ganche network and this provider has a different set of methods on it and these methods allow the web3 library to send a
//request to the local test network(ganache-cli) and to recieve a response of that request .i.e, the ganche and web3 use the provider as a
//communication means between the two and as web3 is always going to be connect to some ethereum network so it always expects to provide a
//provider and if we don't provide a provider it is going to complain that it doesn't know which network it is supposed to talk to.

const {interface,bytecode}=require('../compile');// requiring in the interface and bytecode generated by the compile.js file
//Mocha Functions:
//it:run one individual assertion on something we are trying to test
//describe:used to group together certain it statements
//beforeEach:executes some amount of logic that is common to our tests

//the process of deploying a contract is something we are going to do everytime we are going to run a test usong Mocha
let accounts;//defing the global variable accounts
let inbox;
beforeEach(async()=>{
  //get a list of all the accounts
  accounts=await web3.eth.getAccounts();//web3 has different modules from which are using the .eth module and from the .eth module
 //we are using the getAccounts() function to det the list of all the unlocked accounts and every function we call using web3 is asynchronous
 inbox= await new web3.eth.Contract(JSON.parse(interface))//we parse the json as our solidity compiler gives us a json interpretation of the interface code
 .deploy({data:bytecode,arguments:['hi there this is vivek mehla']})//deploys our bytecode and take argument as the initial string we want to pass to our contracts and the arguments is an array as there might me multiple arguments we might want to pass to our constructor
 .send({from:accounts[0],gas:'1000000'});//specifies using which account we are deploying .i.e, which account is going to pay the gas money
  //make use of one of those accounts to deploy the contract

//inbox is like our javascript representation of our contract we can interact with it and call functions on it .i.e, the inbox object
//represents what exists on the blockchain
});

describe('Inbox',()=>{
  it('contarct deployed to the address',()=>{
      assert.ok(inbox.options.address);// inside the inbox object under the option this address feild give us the address of the block
      //our contract is being deployed too  and if this test passes this means that our contract was successfully deployed to the ganache test network
  });
  it('intial string',async ()=>{
    const message= await inbox.methods.message().call();// here we are calling the instance of our contract(inbox) and it has a property called methods
    //which is an object which contains all of the different public functions in our contract and in the message(any argumnt this function might require)
    //call(if we were attempting to send a transaction this will include the account which will be paying the gas money)
    assert.equal(message,'hi there this is vivek mehla');
  });
  it('sets a new string',async()=>{
    await inbox.methods.setMessage('bie').send({from:accounts[0]});// this wills send us back a hash(transaction reciept)and the .send(tells us who is goung to pay for the transaction)
    const message=await inbox.methods.message().call();
    assert.equal(message,'bie');
  });
});




//DUMMY TEST

// class car{
//   park(){
//     return 'parked';
//   }
//   drive(){
//     return 'vroom';
//   }
// }
// let Car;
// beforeEach(()=>{
//   Car= new car();
// });
//
//
// describe('car',()=>{// car used here is for us to look at in our output and understand that this is our test for the class car it can be named
//   //anything
//   it('car is parked',()=>{
//     // const Car=new car();//creating a instance of our car class
//     assert.equal(Car.park(),'parked');//calling the car.park function using the instance of the car class we just created and comparing it to
//     //the parked string .i.e,if the string returned by the function is equal to the string('parked') that i provided my test will pass otherwise
//     //it will fail
//   });
//
//   it('car is driving' ,()=>{
//     // const ar=new car();
//     assert.equal(Car.drive(),'vroom');
//   });
// });
